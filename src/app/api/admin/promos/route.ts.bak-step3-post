import { NextResponse } from "next/server";
import { createClient } from "@supabase/supabase-js";

export const dynamic = "force-dynamic";
export const revalidate = 0;

const supabase = createClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL!,
  process.env.SUPABASE_SERVICE_ROLE_KEY!
);

type SortKey = "created" | "code" | "type" | "status" | "assigned";

// helper: count(*) with head=true
async function countCodes(filters: (q: ReturnType<typeof supabase.from>) => ReturnType<typeof supabase.from>) {
  let q: any = supabase.from("promo_codes").select("id", { head: true, count: "exact" });
  q = filters(q);
  const { count, error } = await q;
  if (error) throw new Error(error.message);
  return count || 0;
}

export async function GET(req: Request) {
  try {
    const u = new URL(req.url);
    const sp = u.searchParams;

    const qRaw = (sp.get("q") || "").trim();
    const q = qRaw ? `%${qRaw}%` : "";
    const type = sp.get("type") && sp.get("type") !== "all" ? sp.get("type") : "";
    let status = sp.get("status") && sp.get("status") !== "all" ? sp.get("status")! : "";
    if (status === "disabled") status = "archived"; // bwd-compat
    const used = sp.get("used") && sp.get("used") !== "all" ? sp.get("used")! : "";

    const sort: SortKey = (sp.get("sort") as SortKey) || "created";
    const dirAsc = sp.get("dir") === "asc";
    const page = Math.max(1, parseInt(sp.get("page") || "1", 10));
    const limit = Math.max(1, parseInt(sp.get("limit") || "25", 10));
    const from = (page - 1) * limit;
    const to = from + limit - 1;

    const sortMap: Record<SortKey, string> = {
      created: "created_at",
      code: "code",
      type: "type",
      status: "status",
      assigned: "assigned_to_name",
    };

    // --- LIST (paged) ---
    let list = supabase
      .from("promo_codes")
      .select("id, code, type, status, assigned_to_name, created_at", { count: "exact" });

    if (q) list = list.or(`code.ilike.${q},assigned_to_name.ilike.${q}`);
    if (type) list = list.eq("type", type);
    if (status) list = list.eq("status", status);
    if (used === "yes") list = list.eq("status", "consumed");
    if (used === "no")  list = list.neq("status", "consumed");

    list = list.order(sortMap[sort] || "created_at", { ascending: dirAsc, nullsFirst: false }).range(from, to);

    const { data: items, count: total, error: listErr } = await list;
    if (listErr) return NextResponse.json({ ok: false, error: "QUERY_FAILED", detail: listErr.message }, { status: 500 });

    // --- GLOBAL STATS (per type) ---
    const types = ["early_bird", "artist", "staff"] as const;

    // caps (active row)
    const { data: capsRows, error: capErr } = await supabase.from("promo_caps_active").select("type, cap");
    if (capErr) return NextResponse.json({ ok:false, error:"STATS_CAPS_FAILED", detail:capErr.message }, { status:500 });
    const caps: Record<string, number | null> = Object.fromEntries(types.map(t => [t, null]));
    (capsRows || []).forEach((r: any) => { if (r?.type) caps[r.type] = r.cap == null ? null : Number(r.cap); });

    const created: Record<string, number>  = Object.fromEntries(types.map(t => [t, 0]));
    const consumed: Record<string, number> = Object.fromEntries(types.map(t => [t, 0]));
    const inCap:   Record<string, number>  = Object.fromEntries(types.map(t => [t, 0]));

    await Promise.all(types.map(async (t) => {
      const [cAll, cCons, cInCap] = await Promise.all([
        countCodes(q => q.eq("type", t)),
        countCodes(q => q.eq("type", t).eq("status", "consumed")),
        countCodes(q => q.eq("type", t).neq("status", "archived")),
      ]);
      created[t]  = cAll;
      consumed[t] = cCons;
      inCap[t]    = cInCap; // active + reserved + consumed
    }));

    return NextResponse.json({
      ok: true,
      items: items || [],
      total: total || 0,
      stats: { created, consumed, in_cap: inCap, caps }
    });
  } catch (e: any) {
    return NextResponse.json({ ok: false, error: "UNEXPECTED", detail: e?.message || String(e) }, { status: 500 });
  }
}
