import { NextRequest, NextResponse } from "next/server";
import { requireAdmin } from "@/lib/adminAuth";
import { supabaseServer } from "@/lib/supabase-server";

const SAFE = "ABCDEFGHJKMNPQRSTUVWXYZ23456789"; // no I,O,L,0,1

function randFrom(alphabet: string, n: number) {
  let s = "";
  for (let i = 0; i < n; i++) s += alphabet[Math.floor(Math.random() * alphabet.length)];
  return s;
}

function genCode(type: "early_bird"|"artist"|"staff") {
  const head = type === "early_bird" ? "EL" : type === "artist" ? "AR" : "ST";
  const tail = type === "early_bird" ? "B"  : type === "artist" ? "T"  : "F";
  return `${head}${randFrom(SAFE,2)}-${randFrom(SAFE,3)}${tail}`;
}

export async function GET(req: NextRequest) {
  const gate = await requireAdmin(req);
  if ("error" in gate) return gate.error;

  const supabase = supabaseServer();
  const { searchParams } = new URL(req.url);
  const q = (searchParams.get("q") || "").trim().toUpperCase();
  const type = (searchParams.get("type") || "").trim();
  const status = (searchParams.get("status") || "").trim();
  const limit = Math.min(parseInt(searchParams.get("limit") || "50", 10), 200);
  const offset = parseInt(searchParams.get("offset") || "0", 10);

  let query = supabase.from("promo_codes")
    .select("id, code, type, status, used_count, created_at, updated_at, assigned_to_name, assigned_email, assigned_phone, expires_at", { count: "exact" })
    .order("created_at", { ascending: false })
    .range(offset, offset + limit - 1);

  if (q) query = query.ilike("code", `%${q}%`);
  if (type) query = query.eq("type", type);
  if (status) query = query.eq("status", status);

  const { data, error, count } = await query;
  if (error) return NextResponse.json({ ok: false, error: error.message }, { status: 500 });

  return NextResponse.json({ ok: true, items: data, total: count ?? 0 });
}

export async function POST(req: NextRequest) {
  const gate = await requireAdmin(req);
  if ("error" in gate) return gate.error;

  const supabase = supabaseServer();
  const body = await req.json().catch(() => ({}));
  const type = body?.type as "early_bird"|"artist"|"staff";
  const qty = Math.max(1, Math.min(1000, parseInt(body?.qty ?? 1, 10)));
  const assigned_to_name = (body?.assigned_to_name ?? null) as string | null;
  const assigned_email = (body?.assigned_email ?? null) as string | null;
  const assigned_phone = (body?.assigned_phone ?? null) as string | null;
  const note = (body?.note ?? null) as string | null;

  if (!["early_bird","artist","staff"].includes(type)) {
    return NextResponse.json({ ok: false, error: "INVALID_TYPE" }, { status: 400 });
  }

  const rows = [];
  for (let i = 0; i < qty; i++) {
    rows.push({
      code: genCode(type),
      type,
      status: "active",
      assigned_to_name, assigned_email, assigned_phone, note,
      created_by: gate.user.email
    });
  }

  // Insert with retries for unique collisions
  let inserted: any[] = [];
  let remaining = rows;
  for (let attempt = 0; attempt < 5 && remaining.length; attempt++) {
    const { data, error } = await supabase.from("promo_codes").insert(remaining).select("id, code, type, status");
    if (error) {
      // regenerate and retry
      remaining = remaining.map(r => ({ ...r, code: genCode(type) }));
    } else {
      inserted = inserted.concat(data || []);
      remaining = [];
    }
  }

  if (remaining.length) {
    return NextResponse.json({ ok: false, error: "COULD_NOT_GENERATE_UNIQUE" }, { status: 500 });
  }

  return NextResponse.json({ ok: true, created: inserted.length, items: inserted });
}
