import { NextRequest, NextResponse } from "next/server";
import { requireAdmin } from "@/lib/adminAuth";
import { supabaseServer } from "@/lib/supabase-server";

const SAFE = "ABCDEFGHJKMNPQRSTUVWXYZ23456789"; // no I,O,L,0,1

function randFrom(alphabet: string, n: number) {
  let s = "";
  for (let i = 0; i < n; i++) s += alphabet[Math.floor(Math.random() * alphabet.length)];
  return s;
}

function genCode(type: "early_bird"|"artist"|"staff") {
  const head = type === "early_bird" ? "EL" : type === "artist" ? "AR" : "ST";
  const tail = type === "early_bird" ? "B"  : type === "artist" ? "T"  : "F";
  return `${head}${randFrom(SAFE,2)}-${randFrom(SAFE,3)}${tail}`;
}

// ===== GET: list + stats =====
export async function GET(req: NextRequest) {
  const gate = await requireAdmin(req);
  if ("error" in gate) return gate.error;

  const supabase = supabaseServer();
  const { searchParams } = new URL(req.url);
  const q = (searchParams.get("q") || "").trim().toUpperCase();
  const type = (searchParams.get("type") || "").trim();
  const status = (searchParams.get("status") || "").trim();
  const limit = Math.min(parseInt(searchParams.get("limit") || "50", 10), 200);
  const offset = parseInt(searchParams.get("offset") || "0", 10);

  // main list (paged)
  let query = supabase.from("promo_codes")
    .select("id, code, type, status, used_count, created_at, updated_at, assigned_to_name, assigned_email, assigned_phone, expires_at", { count: "exact" })
    .order("created_at", { ascending: false })
    .range(offset, offset + limit - 1);

  if (q) query = query.ilike("code", `%${q}%`);
  if (type) query = query.eq("type", type);
  if (status) query = query.eq("status", status);

  const { data: items, error, count } = await query;
  if (error) return NextResponse.json({ ok: false, error: error.message }, { status: 500 });

  // stats block
  const { data: allForStats, error: e2 } = await supabase
    .from("promo_codes")
    .select("id, type, status, used_count")
    .limit(5000);

  if (e2) return NextResponse.json({ ok: false, error: e2.message }, { status: 500 });

  let ebActive = 0, arActive = 0, staffActive = 0, usedTotal = 0;
  for (const r of (allForStats || [])) {
    if (r.status === "active") {
      if (r.type === "early_bird") ebActive++;
      else if (r.type === "artist") arActive++;
      else if (r.type === "staff") staffActive++;
    }
    usedTotal += Number(r.used_count || 0);
  }
  const stats = {
    active: { early_bird: ebActive, artist: arActive, staff: staffActive },
    caps: { early_bird: 150, artist: 120, staff: null },
    used_total: usedTotal,
    total: count ?? 0,
  };

  return NextResponse.json({ ok: true, items: items || [], total: count ?? 0, stats });
}

// ===== POST: create (bulk or single) =====
export async function POST(req: NextRequest) {
  const gate = await requireAdmin(req);
  if ("error" in gate) return gate.error;

  const supabase = supabaseServer();
  const body = await req.json().catch(() => ({}));
  const type = body?.type as "early_bird"|"artist"|"staff";
  const qty = Math.max(1, Math.min(1000, parseInt(body?.qty ?? 1, 10)));
  const assigned_to_name = (body?.assigned_to_name ?? null) as string | null;
  const assigned_email = (body?.assigned_email ?? null) as string | null;
  const assigned_phone = (body?.assigned_phone ?? null) as string | null;
  const note = (body?.note ?? null) as string | null;

  if (!["early_bird","artist","staff"].includes(type)) {
    return NextResponse.json({ ok: false, error: "INVALID_TYPE" }, { status: 400 });
  }

  // prepare rows
  const rows = [];
  for (let i = 0; i < qty; i++) {
    rows.push({
      code: genCode(type),
      type,
      status: "active",
      assigned_to_name, assigned_email, assigned_phone, note,
      created_by: gate.user.email,
    });
  }

  // insert with retry for unique collisions
  let inserted: any[] = [];
  let remaining = rows;
  for (let attempt = 0; attempt < 5 && remaining.length; attempt++) {
    const { data, error } = await supabase
      .from("promo_codes")
      .insert(remaining)
      .select("id, code, type, status");

    if (error) {
      // regenerate codes and retry
      remaining = remaining.map(r => ({ ...r, code: genCode(type) }));
    } else {
      inserted = inserted.concat(data || []);
      remaining = [];
    }
  }

  if (remaining.length) {
    return NextResponse.json({ ok: false, error: "COULD_NOT_GENERATE_UNIQUE" }, { status: 500 });
  }

  return NextResponse.json({ ok: true, created: inserted.length, items: inserted });
}
