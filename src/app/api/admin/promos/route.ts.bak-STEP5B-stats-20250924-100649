// STEP 5B — server-driven sorting & pagination for admin/promos
import { NextResponse } from "next/server";
import { supabaseServer } from "@/lib/supabase-server";

type SortKey = "created" | "type" | "status";
const SORT_COLS: Record<SortKey, string> = {
  created: "created_at",
  type: "type",
  status: "status",
};

function parseParams(url: URL) {
  const q = (url.searchParams.get("q") || "").trim();
  const type = url.searchParams.get("type") || "";        // early_bird|artist|staff|all/empty
  const status = url.searchParams.get("status") || "";    // active|reserved|consumed|disabled|all/empty
  const used = url.searchParams.get("used") || "";        // yes|no|all/empty
  const assigned = url.searchParams.get("assigned") || "";// assigned|unassigned|all/empty
  const sort = (url.searchParams.get("sort") as SortKey) || "created";
  const dir = (url.searchParams.get("dir") || "desc").toLowerCase() === "asc" ? "asc" : "desc";
  const limit = Math.min(Math.max(parseInt(url.searchParams.get("limit") || "50", 10), 1), 100);
  const offset = Math.max(parseInt(url.searchParams.get("offset") || "0", 10), 0);
  return { q, type, status, used, assigned, sort, dir, limit, offset };
}

export async function GET(req: Request) {
  // Auth: require Supabase session token as Bearer
  const auth = req.headers.get("authorization") || "";
  if (!auth.toLowerCase().startsWith("bearer ")) {
    return NextResponse.json({ ok: false, error: "Unauthorized" }, { status: 401 });
  }

  const url = new URL(req.url);
  const { q, type, status, used, assigned, sort, dir, limit, offset } = parseParams(url);
  const supa = supabaseServer();

  const sortCol = SORT_COLS[sort] ?? "created_at";
  let query = supa.from("promo_codes").select("*", { count: "exact" });

  // Filters
  if (q) {
    query = query.or([
      `code.ilike.%${q}%`,
      `note.ilike.%${q}%`,
      `assigned_to_name.ilike.%${q}%`,
      `assigned_to_email.ilike.%${q}%`,
      `assigned_to_phone.ilike.%${q}%`,
    ].join(","));
  }
  if (type && type !== "all") query = query.eq("type", type);
  if (status && status !== "all") query = query.eq("status", status);

  if (used === "yes")      query = query.gt("used_count", 0);
  else if (used === "no")  query = query.eq("used_count", 0);

  if (assigned === "assigned") {
    // Any assigned field present → assigned
    query = query.or("assigned_to_name.not.is.null,assigned_to_email.not.is.null,assigned_to_phone.not.is.null");
  } else if (assigned === "unassigned") {
    query = query.is("assigned_to_name", null).is("assigned_to_email", null).is("assigned_to_phone", null);
  }

  // Sorting + paging
  query = query.order(sortCol, { ascending: dir === "asc" }).range(offset, offset + limit - 1);

  const { data: items, error, count } = await query;
  if (error) {
    return NextResponse.json({ ok: false, error: error.message }, { status: 500 });
  }

  // Stats strip (exclude disabled). If you have an RPC, call it here.
  // Fallback: compute quickly here.
  const { data: rawStats } = await supa
    .from("promo_codes")
    .select("type,status", { count: "exact" })
    .neq("status", "disabled");

  // Prepare a minimal stats object: counts per type/status (client can format)
  const stats = { byType: { early_bird: 0, artist: 0, staff: 0 }, byStatus: { active: 0, reserved: 0, consumed: 0 } };
  if (rawStats) {
    for (const row of rawStats as any[]) {
      if (row.type in stats.byType)   (stats.byType as any)[row.type] += 1;
      if (row.status in stats.byStatus) (stats.byStatus as any)[row.status] += 1;
    }
  }

  return NextResponse.json({
    ok: true,
    items: items ?? [],
    total: count ?? 0,
    stats,
  });
}
