import { NextRequest, NextResponse } from "next/server";
import { supabaseServer } from "@/lib/supabase-server";


// Bookings that consume ship capacity
const CAPACITY_STATUSES = ['DEPOSIT_CONFIRMED','ON_HOLD'] as const;
type CategoryKey = "INTERIOR" | "OCEANVIEW" | "BALCONY";
type Supports = { double: boolean; triple: boolean; quad: boolean };
type CabinConfig = Record<CategoryKey, { supports: Supports }>;
type CabinInventory = Record<CategoryKey, { total: number; double_only: number; flex: number }>;
type Layout = { doubles: number; triples: number; quads: number; cabins: number; seats: number };

const LABELS: Record<CategoryKey,string> = {
  INTERIOR: "Interior",
  OCEANVIEW: "Ocean View",
  BALCONY: "Balcony",
};

function fmtMXN(cents: number) {
  const v = Math.round(cents/100);
  return "MXN " + v.toLocaleString("en-US");
}

function* generateLayouts(N: number, supports: Supports): Generator<Layout> {
  const canD = supports.double, canT = supports.triple, canQ = supports.quad;
  for (let q = 0; q <= (canQ ? Math.floor(N/4) : 0); q++) {
    const remAfterQ = N - 4*q;
    for (let t = 0; t <= (canT ? Math.floor(remAfterQ/3) : 0); t++) {
      const remAfterT = remAfterQ - 3*t;
      if (!canD) {
        if (remAfterT === 0) {
          const cabins = q + t;
          yield { doubles: 0, triples: t, quads: q, cabins, seats: N };
        }
        continue;
      }
      if (remAfterT % 2 !== 0) continue;
      const d = remAfterT/2;
      const cabins = q + t + d;
      if (cabins <= 0) continue;
      yield { doubles: d, triples: t, quads: q, cabins, seats: N };
    }
  }
}

function staticFeasible(layout: Layout, inv: CabinInventory[CategoryKey], sup: Supports, adults: number) {
  if (layout.triples > 0 && !sup.triple) return false;
  if (layout.quads   > 0 && !sup.quad)   return false;
  if (layout.doubles > 0 && !sup.double) return false;
  if (adults < layout.cabins) return false;

  // Static ship constraints (no live usage here)
  const usedFlex = layout.triples + layout.quads;
  if (usedFlex > inv.flex) return false;
  const maxDoubles = inv.double_only + (inv.flex - usedFlex);
  if (layout.doubles > maxDoubles) return false;
  if (layout.cabins > inv.total) return false;

  return true;
}

export async function GET(req: NextRequest) {
  try {
    const ref = req.cookies.get("ccc_ref")?.value;
    if (!ref) return NextResponse.json({ ok:false, error:"MISSING_REF" }, { status:401 });

    const supabase = supabaseServer();

    // Lead
    const { data: lead } = await supabase
      .from("leads")
      .select("booking_ref, adults, minors")
      .eq("booking_ref", ref)
      .single();
    if (!lead) return NextResponse.json({ ok:false, error:"LEAD_NOT_FOUND" }, { status:404 });

    const groupSize = (lead.adults ?? 0) + (lead.minors ?? 0);
    const adults = lead.adults ?? 0;

    // Travelers -> promo counts
    const { data: travelers } = await supabase
      .from("travelers")
      .select("promo_code_id")
      .eq("booking_ref", ref);

    const promoIds = (travelers ?? []).map(t=>t.promo_code_id).filter(Boolean);
    let staffCount=0, artistCount=0, ebCount=0;
    if (promoIds.length) {
      const { data: promos } = await supabase
        .from("promo_codes")
        .select("id,type")
        .in("id", promoIds);
      for (const p of promos ?? []) {
        if (p.type === "staff") staffCount++;
        else if (p.type === "artist") artistCount++;
        else if (p.type === "early_bird") ebCount++;
      }
    }
    const hasStaff = staffCount>0, hasArtist = artistCount>0, hasEb = ebCount>0;

    // settings
    const { data: cfgRow } = await supabase
      .from("settings").select("value").eq("key","cabin_config").single();
    const { data: invRow } = await supabase
      .from("settings").select("value").eq("key","cabin_inventory").single();
    const CONFIG = (cfgRow?.value ?? {}) as CabinConfig;
    const INVENTORY = (invRow?.value ?? {}) as CabinInventory;

    // prices
    const { data: prices } = await supabase
      .from("current_public_prices")
      .select("category, occupancy, price_cents");
    const priceMap = new Map<string, number>();
    for (const r of prices ?? []) priceMap.set(`${r.category}|${r.occupancy}`, r.price_cents);
    const pp = (category: CategoryKey, occ: "DOUBLE"|"TRIPLE"|"QUADRUPLE") =>
      priceMap.get(`${category}|${occ}`) ?? 0;

    // promo caps (per category)
    const { data: caps } = await supabase
      .from("promo_caps_remaining_by_category")
      .select("type, category, remaining");
    const capRem = { artist: new Map<CategoryKey|"null",number>(), early_bird: new Map<CategoryKey|"null",number>() };
    for (const c of caps ?? []) {
      const key = (c.category ?? "null") as any;
      if (c.type === "artist") capRem.artist.set(key, Number(c.remaining ?? 0));
      if (c.type === "early_bird") capRem.early_bird.set(key, Number(c.remaining ?? 0));
    }

    // ---- NEW: live usage from CONFIRMED bookings
    const { data: usedRows, error: usedErr } = await supabase
      .from("cabins")
      .select("category, occupancy, bookings!inner(status)")
      .eq("bookings.status", "CONFIRMED");
    if (usedErr) return NextResponse.json({ ok:false, error: usedErr.message }, { status:500 });

    type UsedAgg = Record<CategoryKey, { doubles: number; triples: number; quads: number }>;
    const used: UsedAgg = {
      INTERIOR: { doubles:0, triples:0, quads:0 },
      OCEANVIEW:{ doubles:0, triples:0, quads:0 },
      BALCONY:  { doubles:0, triples:0, quads:0 },
    };
    for (const row of usedRows ?? []) {
      const cat = (row as any).category as CategoryKey;
      const occ = Number((row as any).occupancy);
      if (!used[cat]) continue;
      if (occ === 2) used[cat].doubles++;
      else if (occ === 3) used[cat].triples++;
      else if (occ === 4) used[cat].quads++;
    }

    function remainingFor(cat: CategoryKey) {
      const inv = INVENTORY[cat] ?? { total:999, double_only:999, flex:999 };
      const u = used[cat] ?? { doubles:0, triples:0, quads:0 };
      const usedTotal = u.doubles + u.triples + u.quads;

      // Doubles first fill double_only, overflow into flex; triples/quads always flex
      const usedDoubleOnly = Math.min(u.doubles, inv.double_only);
      const usedFlexFromDoubles = Math.max(0, u.doubles - inv.double_only);
      const usedFlex = u.triples + u.quads + usedFlexFromDoubles;

      return {
        totalRem: Math.max(0, inv.total - usedTotal),
        doubleOnlyRem: Math.max(0, inv.double_only - usedDoubleOnly),
        flexRem: Math.max(0, inv.flex - usedFlex),
      };
    }

    function fitsLiveRemaining(cat: CategoryKey, layout: Layout) {
      const rem = remainingFor(cat);

      // Flex needed by layout: triples+quads plus doubles that overflow past doubleOnlyRem
      const flexNeeded = layout.triples + layout.quads + Math.max(0, layout.doubles - rem.doubleOnlyRem);

      // Doubles overall must not exceed doubleOnlyRem + flexRem
      const doublesPossible = rem.doubleOnlyRem + rem.flexRem;

      if (layout.doubles > doublesPossible) return false;
      if (flexNeeded > rem.flexRem) return false;
      if (layout.cabins > rem.totalRem) return false;
      return true;
    }

    function publicTotalCents(category: CategoryKey, layout: Layout) {
      const total =
        layout.doubles   * pp(category, "DOUBLE") +
        layout.triples   * pp(category, "TRIPLE") +
        layout.quads     * pp(category, "QUADRUPLE");
      return total;
    }

    const categories: CategoryKey[] = ["INTERIOR","OCEANVIEW","BALCONY"];
    const out: any[] = [];

    for (const cat of categories) {
      const supports = CONFIG[cat]?.supports ?? { double:true, triple:true, quad:true };
      const inv = INVENTORY[cat] ?? { total:999, double_only:999, flex:999 };

      // Promo caps gating (strict)
      const needArtist = artistCount;
      const needEb = ebCount;
      const remArtist = Number(capRem.artist.get(cat) ?? Infinity);
      const remEb = Number(capRem.early_bird.get(cat) ?? Infinity);
      let disabledReason: string | null = null;
      if (needArtist > remArtist || needEb > remEb) {
        disabledReason = "Not available with your promo codes right now.";
      }

      // From price
      const fromCents = pp(cat,"DOUBLE");

      // Generate + filter layouts by static feasibility
      const staticLayouts: Layout[] = [];
      for (const L of generateLayouts(groupSize, supports)) {
        if (staticFeasible(L, inv, supports, adults)) staticLayouts.push(L);
      }

      // NEW: filter by live remaining (no oversell). Then rank.
      const liveOK = staticLayouts.filter(L => fitsLiveRemaining(cat, L));
      liveOK.sort((a,b)=>{
        if (a.cabins !== b.cabins) return a.cabins - b.cabins;
        return publicTotalCents(cat, a) - publicTotalCents(cat, b); // ranking by PUBLIC only (per your decision)
      });

      const top = liveOK.slice(0,3).map((x, i)=>({
        doubles: x.doubles,
        triples: x.triples,
        quads:   x.quads,
        cabins:  x.cabins,
        seats:   x.seats,
        totalCents: publicTotalCents(cat, x),
        totalLabel: fmtMXN(publicTotalCents(cat, x)),
        recommended: i===0,
      }));

      // If no live-feasible layouts remain, hard-disable by capacity
      if (!disabledReason && top.length === 0) {
        disabledReason = "Not available â€” this category is at capacity.";
      }

      // Per-category promo remaining for chips (UI will show only if hasArtist/hasEb)
      const artistRemaining = Number(capRem.artist.get(cat) ?? 0);
      const ebRemaining = Number(capRem.early_bird.get(cat) ?? 0);

      out.push({
        key: cat,
        label: LABELS[cat],
        fromCents,
        fromLabel: `${fmtMXN(fromCents)} pp (double)`,
        hasStaff, hasArtist, hasEb,
        artistRemaining, ebRemaining,
        disabledReason,
        layouts: top,
      });
    }

    return NextResponse.json({ ok:true, groupSize, adults, categories: out }, { status:200 });
  } catch (err: any) {
    return NextResponse.json({ ok:false, error: err?.message || "Server error" }, { status:500 });
  }
}
