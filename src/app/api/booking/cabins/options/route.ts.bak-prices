import { NextRequest, NextResponse } from "next/server";
import { supabaseServer } from "@/lib/supabase-server";

type CategoryKey = "INTERIOR" | "OCEANVIEW" | "BALCONY";
type Supports = { double: boolean; triple: boolean; quad: boolean };
type CabinConfig = Record<CategoryKey, { supports: Supports }>;
type CabinInventory = Record<CategoryKey, { total: number; double_only: number; flex: number }>;

type Layout = { doubles: number; triples: number; quads: number; cabins: number; seats: number };

const LABELS: Record<CategoryKey,string> = {
  INTERIOR: "Interior",
  OCEANVIEW: "Ocean View",
  BALCONY: "Balcony",
};

function fmtMXN(cents: number) {
  const v = Math.round(cents/100);
  return "MXN " + v.toLocaleString("en-US");
}

function seatList(layout: Layout): ("DOUBLE"|"TRIPLE"|"QUADRUPLE")[] {
  const out: ("DOUBLE"|"TRIPLE"|"QUADRUPLE")[] = [];
  for (let i=0;i<layout.doubles;i++) out.push("DOUBLE");
  for (let i=0;i<layout.triples;i++) out.push("TRIPLE");
  for (let i=0;i<layout.quads;i++) out.push("QUADRUPLE");
  return out;
}

function feasible(layout: Layout, inv: CabinInventory[CategoryKey], sup: Supports, adults: number) {
  // supports
  if (layout.triples > 0 && !sup.triple) return false;
  if (layout.quads   > 0 && !sup.quad)   return false;
  if (layout.doubles > 0 && !sup.double) return false;

  // adult-per-cabin (cheap guard)
  if (adults < layout.cabins) return false;

  // ship-level constraints: flex vs double_only
  const usedFlex = layout.triples + layout.quads;
  if (usedFlex > inv.flex) return false;
  const maxDoubles = inv.double_only + (inv.flex - usedFlex);
  if (layout.doubles > maxDoubles) return false;

  // total cabins
  if (layout.cabins > inv.total) return false;

  return true;
}

function* generateLayouts(N: number, supports: Supports): Generator<Layout> {
  // N is group size (<=10 in your flow)
  // Try reasonable cabin counts up to N (since min 1 pax/seat >=2)
  const canD = supports.double, canT = supports.triple, canQ = supports.quad;

  // brute within small bounds
  for (let q = 0; q <= (canQ ? Math.floor(N/4) : 0); q++) {
    const remAfterQ = N - 4*q;
    for (let t = 0; t <= (canT ? Math.floor(remAfterQ/3) : 0); t++) {
      const remAfterT = remAfterQ - 3*t;
      if (!canD) {
        if (remAfterT === 0) {
          const cabins = q + t;
          yield { doubles: 0, triples: t, quads: q, cabins, seats: N };
        }
        continue;
      }
      if (remAfterT % 2 !== 0) continue;
      const d = remAfterT/2;
      const cabins = q + t + d;
      if (cabins <= 0) continue;
      yield { doubles: d, triples: t, quads: q, cabins, seats: N };
    }
  }
}

export async function GET(req: NextRequest) {
  try {
    const ref = req.cookies.get("ccc_ref")?.value;
    if (!ref) return NextResponse.json({ ok:false, error:"MISSING_REF" }, { status:401 });

    const supabase = supabaseServer();

    // group + names + promos
    const { data: lead } = await supabase
      .from("leads")
      .select("booking_ref, adults, minors")
      .eq("booking_ref", ref)
      .single();

    if (!lead) return NextResponse.json({ ok:false, error:"LEAD_NOT_FOUND" }, { status:404 });

    const groupSize = (lead.adults ?? 0) + (lead.minors ?? 0);
    const adults = lead.adults ?? 0;

    const { data: travelers } = await supabase
      .from("travelers")
      .select("promo_code_id")
      .eq("booking_ref", ref);

    const promoIds = (travelers ?? []).map(t=>t.promo_code_id).filter(Boolean);
    let staffCount=0, artistCount=0, ebCount=0;
    if (promoIds.length) {
      const { data: promos } = await supabase
        .from("promo_codes")
        .select("id,type")
        .in("id", promoIds);
      for (const p of promos ?? []) {
        if (p.type === "staff") staffCount++;
        else if (p.type === "artist") artistCount++;
        else if (p.type === "early_bird") ebCount++;
      }
    }
    const hasStaff = staffCount>0, hasArtist = artistCount>0, hasEb = ebCount>0;

    // settings
    const { data: cfgRow } = await supabase
      .from("settings")
      .select("value")
      .eq("key","cabin_config")
      .single();
    const { data: invRow } = await supabase
      .from("settings")
      .select("value")
      .eq("key","cabin_inventory")
      .single();

    const CONFIG = (cfgRow?.value ?? {}) as CabinConfig;
    const INVENTORY = (invRow?.value ?? {}) as CabinInventory;

    // prices (current public per-person)
    const { data: prices } = await supabase
      .from("current_public_prices")
      .select("category, occupancy, price_cents");

    const priceMap = new Map<string, number>();
    for (const r of prices ?? []) {
      priceMap.set(`${r.category}|\${r.occupancy}`, r.price_cents);
    }

    function pp(category: CategoryKey, occ: "DOUBLE"|"TRIPLE"|"QUADRUPLE") {
      return priceMap.get(`${category}|\${occ}`) ?? 0;
    }

    // caps remaining per category (artist/early_bird)
    const { data: caps } = await supabase
      .from("promo_caps_remaining_by_category")
      .select("type, category, remaining");

    const capRem = { artist: new Map<CategoryKey|"null",number>(), early_bird: new Map<CategoryKey|"null",number>() };
    for (const c of caps ?? []) {
      const key = (c.category ?? "null") as any;
      if (c.type === "artist") capRem.artist.set(key, Number(c.remaining ?? 0));
      if (c.type === "early_bird") capRem.early_bird.set(key, Number(c.remaining ?? 0));
    }

    function bestPlacementTotalCents(category: CategoryKey, layout: Layout) {
      // Build seat price list for this layout (per-person public)
      const seats = [
        ...Array(layout.doubles).fill(pp(category,"DOUBLE")),
        ...Array(layout.triples).fill(pp(category,"TRIPLE")),
        ...Array(layout.quads).fill(pp(category,"QUADRUPLE")),
      ].sort((a,b)=>b-a); // expensive first

      // Counts of promos:
      let staff = staffCount, artist = artistCount, eb = ebCount;

      let total = 0;
      for (const seatPrice of seats) {
        let seat = seatPrice;

        if (staff > 0) {
          // Staff pays upgrade vs Interior for this occupancy
          const occ = seatPrice===pp(category,"QUADRUPLE") ? "QUADRUPLE" :
                      seatPrice===pp(category,"TRIPLE") ? "TRIPLE" : "DOUBLE";
          const interiorSeat = pp("INTERIOR", occ as any);
          seat = Math.max(0, seatPrice - interiorSeat);
          staff--;
        } else if (artist > 0) {
          seat = Math.round(seatPrice * 0.5);
          artist--;
        } else if (eb > 0) {
          seat = Math.round(seatPrice * 0.85);
          eb--;
        } else {
          // public price
        }
        total += seat;
      }
      return total;
    }

    const categories: CategoryKey[] = ["INTERIOR","OCEANVIEW","BALCONY"];
    const out: any[] = [];

    for (const cat of categories) {
      const supports = CONFIG[cat]?.supports ?? { double:true, triple:true, quad:true };
      const inv = INVENTORY[cat] ?? { total:999, double_only:999, flex:999 };

      // Strict caps gating: if we need more capped promos than remaining -> whole category disabled
      const needArtist = artistCount;
      const needEb = ebCount;
      const remArtist = Number(capRem.artist.get(cat) ?? Infinity);
      const remEb = Number(capRem.early_bird.get(cat) ?? Infinity);

      let disabledReason: string | null = null;
      if (needArtist > remArtist || needEb > remEb) {
        disabledReason = "Not available with your promo codes right now.";
      }

      // From price (public double)
      const fromCents = pp(cat,"DOUBLE");

      // Build feasible layouts
      const layouts: Array<{ layout: Layout; totalCents: number }> = [];
      for (const L of generateLayouts(groupSize, supports)) {
        if (!feasible(L, inv, supports, adults)) continue;
        const total = bestPlacementTotalCents(cat, L);
        layouts.push({ layout: L, totalCents: total });
      }

      // Rank: fewest cabins â†’ cheapest total
      layouts.sort((a,b)=>{
        if (a.layout.cabins !== b.layout.cabins) return a.layout.cabins - b.layout.cabins;
        return a.totalCents - b.totalCents;
      });

      const top = layouts.slice(0,3).map((x, i)=>({
        doubles: x.layout.doubles,
        triples: x.layout.triples,
        quads:   x.layout.quads,
        cabins:  x.layout.cabins,
        seats:   x.layout.seats,
        totalCents: x.totalCents,
        totalLabel: fmtMXN(x.totalCents),
        recommended: i===0,
      }));

      out.push({
        key: cat,
        label: LABELS[cat],
        fromCents,
        fromLabel: `${fmtMXN(fromCents)} pp (double)`,
        hasStaff, hasArtist, hasEb,
        disabledReason,
        layouts: top,
      });
    }

    return NextResponse.json({ ok:true, groupSize, adults, categories: out }, { status:200 });
  } catch (err: any) {
    return NextResponse.json({ ok:false, error: err?.message || "Server error" }, { status:500 });
  }
}
