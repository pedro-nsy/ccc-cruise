import { NextRequest, NextResponse } from "next/server";
import { supabaseServer } from "@/lib/supabase-server";
import { fetchCurrentPrices, computeBestPlacementTotalCents, type Category, type Occupancy } from "@/lib/pricing";

type CabinConfig = Record<Category, { supports:{ double:boolean; triple:boolean; quad:boolean } }>;
type CabinInventory = Record<Category, { total:number; double_only:number; flex:number }>;

function expand(n:number, occs: Occupancy[]): Occupancy[][] {
  // enumerate non-negative solutions to 2d+3t+4q = n, limited to occupancies allowed later
  const out: Occupancy[][] = [];
  for (let q=0; q*4<=n; q++){
    for (let t=0; t*3+q*4<=n; t++){
      const rem = n - (t*3 + q*4);
      if (rem % 2 !== 0) continue;
      const d = rem / 2;
      if (d<0) continue;
      const occ: Occupancy[] = ([] as Occupancy[])
        .concat(Array(q).fill(4) as Occupancy[])
        .concat(Array(t).fill(3) as Occupancy[])
        .concat(Array(d).fill(2) as Occupancy[]);
      out.push(occ);
    }
  }
  return out;
}
function count(occ: Occupancy[], x: Occupancy){ return occ.reduce((a,b)=>a+(b===x?1:0),0); }

export async function GET(req: NextRequest) {
  try {
    const ref = req.cookies.get("ccc_ref")?.value;
    if (!ref) return NextResponse.json({ ok:false, error:"MISSING_REF" }, { status:401 });

    const sb = supabaseServer();

    // Load lead (adults/minors) + travelers (promos)
    const { data: lead, error: leadErr } = await sb
      .from("leads")
      .select("booking_ref, adults, minors")
      .eq("booking_ref", ref)
      .single();
    if (leadErr || !lead) return NextResponse.json({ ok:false, error:"LEAD_NOT_FOUND" }, { status:404 });
    const groupSize = (lead.adults||0) + (lead.minors||0);

    const { data: travelers, error: tErr } = await sb
      .from("travelers")
      .select("idx,is_adult,promo_code_id")
      .eq("booking_ref", ref)
      .order("idx",{ ascending:true });
    if (tErr) return NextResponse.json({ ok:false, error:tErr.message }, { status:500 });

    // promo type map
    let rawIds = (travelers||[]).map(t=>t.promo_code_id).filter(Boolean);
    const idsNum = (rawIds as any[]).filter(v=>typeof v==="number") as number[];
    const idsStr = (rawIds as any[]).filter(v=>typeof v!=="number").map(String) as string[];
    const promoMap: Record<string, { type:"early_bird"|"artist"|"staff" }> = {};
    if (idsNum.length) {
      const { data } = await sb.from("promo_codes").select("id,type").in("id", idsNum);
      (data||[]).forEach((p:any)=>promoMap[String(p.id)] = { type:p.type });
    }
    if (idsStr.length) {
      const { data } = await sb.from("promo_codes").select("id,type").in("id", idsStr);
      (data||[]).forEach((p:any)=>promoMap[String(p.id)] = { type:p.type });
    }

    const promoCountsAll = { staff:0, artist:0, eb:0, none:0 };
    for (const t of (travelers||[])) {
      const ty = t.promo_code_id ? promoMap[String(t.promo_code_id)]?.type : null;
      if (ty === "staff") promoCountsAll.staff++;
      else if (ty === "artist") promoCountsAll.artist++;
      else if (ty === "early_bird") promoCountsAll.eb++;
      else promoCountsAll.none++;
    }

    // load settings
    const cfg = await sb.from("settings").select("key,value").in("key",["cabin_config","cabin_inventory"]).then(r=>{
      if (r.error) throw new Error(r.error.message);
      const m: Record<string, any> = {};
      for (const row of r.data||[]) m[row.key] = row.value;
      return m;
    });
    const cabinConfig = cfg.cabin_config as CabinConfig;
    const inventory   = cfg.cabin_inventory as CabinInventory;

    // promo caps remaining per category (strict block logic)
    const { data: caps, error: capsErr } = await sb
      .from("promo_caps_remaining_by_category")
      .select("type, category, remaining");
    if (capsErr) return NextResponse.json({ ok:false, error:capsErr.message }, { status:500 });

    const remainingByTypeCat = new Map<string, number>();
    (caps||[]).forEach((r:any)=>{
      const key = `${r.type}::${r.category||"null"}`;
      remainingByTypeCat.set(key, r.remaining);
    });

    // generator for layouts per category with feasibility rules
    const basePrice = await fetchCurrentPrices();
    const categories: Category[] = ["INTERIOR","OCEANVIEW","BALCONY"];
    const out: any[] = [];

    for (const cat of categories) {
      // supports
      const sup = cabinConfig?.[cat]?.supports || { double:true, triple:true, quad:true };

      // strict caps block?
      const artistRem = remainingByTypeCat.get(`artist::${cat}`) ?? 0;
      const ebRem     = remainingByTypeCat.get(`early_bird::${cat}`) ?? 0;
      const needArtist= promoCountsAll.artist;
      const needEb    = promoCountsAll.eb;
      const blocked   = (needArtist > 0 && needArtist > artistRem) || (needEb > 0 && needEb > ebRem);

      // candidate layouts (sum to groupSize)
      let layouts = expand(groupSize,[2,3,4] as Occupancy[])
        .filter(occ=>{
          if (!sup.triple && occ.includes(3)) return false;
          if (!sup.quad   && occ.includes(4)) return false;
          return true;
        });

      // adult-per-cabin cheap guard (cabins <= adults)
      const adults = (lead.adults||0);
      layouts = layouts.filter(occ => occ.length <= adults);

      // ship-level shape constraints (double_only vs flex)
      const inv = inventory?.[cat] || { total: 9999, double_only: 9999, flex: 9999 };
      layouts = layouts.filter(occ=>{
        const d = count(occ,2);
        const t = count(occ,3);
        const q = count(occ,4);
        const totalCabins = d+t+q;
        if (totalCabins > inv.total) return false;
        if (t+q > inv.flex) return false;          // triples+quads must fit in flex
        if (d > inv.double_only + inv.flex) return false; // doubles can be double_only or flex
        return true;
      });

      // De-dup (expand can produce same mix in different order)
      const key = (a: Occupancy[]) => `${count(a,2)}-${count(a,3)}-${count(a,4)}`;
      const seen = new Set<string>();
      layouts = layouts.filter(l=>{ const k=key(l); if (seen.has(k)) return false; seen.add(k); return true; });

      // price + ranking
      const priced = layouts.map(occ => {
        const total = computeBestPlacementTotalCents({
          category: cat,
          occupancies: occ,
          basePrice,
          promoCounts: promoCountsAll,
        });
        return { occ, total };
      });

      // rank: fewest cabins → cheapest total → (tie-breaker: more flex headroom)
      priced.sort((a,b)=>{
        const c = a.occ.length - b.occ.length;
        if (c !== 0) return c;
        const p = a.total - b.total;
        if (p !== 0) return p;
        // headroom = how many flex cabins remain if we chose this layout
        const flexUsed = count(a.occ,3)+count(a.occ,4);
        const flexUsedB= count(b.occ,3)+count(b.occ,4);
        return (flexUsed - flexUsedB);
      });

      const top = priced.slice(0,3).map(x=>({
        doubles: count(x.occ,2),
        triples: count(x.occ,3),
        quads:   count(x.occ,4),
        cabins:  x.occ.length,
        total_cents: x.total,
      }));

      out.push({
        category: cat,
        from_price_cents: basePrice(cat, 2), // per your spec: show ONLY double price
        promo_need: { artist: needArtist, eb: needEb },
        promo_remaining: {
          artist: artistRem,
          eb: ebRem,
        },
        blocked, // strict caps block
        layouts: top,
      });
    }

    // chips visibility: only show the promo(s) present in travelers
    const showArtistChip = promoCountsAll.artist > 0;
    const showEbChip     = promoCountsAll.eb > 0;

    return NextResponse.json({
      ok:true,
      groupSize,
      promoCounts: promoCountsAll,
      showChips: { artist: showArtistChip, eb: showEbChip },
      categories: out,
    }, { status:200 });

  } catch (e:any) {
    return NextResponse.json({ ok:false, error: e?.message || "Server error" }, { status:500 });
  }
}
